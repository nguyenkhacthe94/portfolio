<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COUNT(1) and COUNT(*) in SQL Server - The Nguyen Khac</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=DM+Sans:wght@400;500;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../css/posts.css">
</head>

<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <article>
            <!-- Article Header -->
            <header class="article-header">
                <div class="article-meta">Technical Article â€¢ SQL Server</div>
                <h1>COUNT(1) and COUNT(*) in SQL Server</h1>
                <img src="../../img/count_in_sql_server_thumbnail.png" alt="COUNT(1) and COUNT(*) in SQL Server"
                    class="article-thumbnail">
                <p class="article-intro">
                    There is a common myth about COUNT(1) and COUNT(*) that COUNT(1) is faster than COUNT(*), because
                    the COUNT(*) query scans the whole table, but COUNT(1) does not. Let's check it out.
                </p>
            </header>

            <!-- Article Content -->
            <div class="article-content">
                <p>First, we'll start with the execution plan.</p>

                <img src="../../img/count_in_sql_server_1.jfif" alt="Execution Plan">
                <p class="image-caption">COUNT(1) and COUNT(*)</p>

                <p>
                    Here you can see that both COUNT(1) and COUNT(*) use the same execution plan. Both have the same
                    query cost of 50%.
                </p>

                <p>Let's check the query profile and I/O by using the below commands:</p>

                <img src="../../img/count_in_sql_server_2.png" alt="Query profile check">
                <p class="image-caption">Query profile check</p>

                <p>Here we have the result:</p>

                <pre><code>SELECT COUNT(*) FROM [Sales].[SalesOrderDetail]
  |--Compute Scalar(DEFINE:([Expr1002]=CONVERT_IMPLICIT(int,[Expr1003],0)))
       |--Stream Aggregate(DEFINE:([Expr1003]=Count(*)))
            |--Index Scan(OBJECT:([AdventureWorks2014].[Sales].[SalesOrderDetail].[IX_SalesOrderDetail_ProductID]))

SELECT COUNT(1) FROM [Sales].[SalesOrderDetail]
  |--Compute Scalar(DEFINE:([Expr1002]=CONVERT_IMPLICIT(int,[Expr1003],0)))
       |--Stream Aggregate(DEFINE:([Expr1003]=Count(*)))
            |--Index Scan(OBJECT:([AdventureWorks2014].[Sales].[SalesOrderDetail].[IX_SalesOrderDetail_ProductID]))</code></pre>

                <p>
                    The PROFILE data of both queries shows COUNT(*). That means the SQL engine internally converts
                    COUNT(1) to COUNT(*). Let's continue with the I/O stats:
                </p>

                <pre><code>Table 'SalesOrderDetail'. Scan count 1, logical reads 276, physical reads 1, 
 read-ahead reads 288, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.

Table 'SalesOrderDetail'. Scan count 1, logical reads 276, physical reads 0, 
 read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre>

                <p>Both queries read 276 pages.</p>

                <p>
                    Based on the above prooves, we can clearly say with no doubt that, <strong>THERE IS NO DIFFERENCE
                        BETWEEN COUNT(1) AND COUNT(*).</strong>
                </p>
            </div>
        </article>
    </div>

    <div id="footer-placeholder"></div>

    <script src="../../js/post_layout.js"></script>
</body>

</html>
