<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic in Java (Pt. 2) - The Nguyen Khac</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Lora:wght@400;500;600;700&family=DM+Sans:wght@400;500;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../css/posts.css">
</head>

<body>
    <div id="nav-placeholder"></div>

    <div class="container">
        <article>
            <!-- Article Header -->
            <header class="article-header">
                <div class="article-meta">Technical Article â€¢ Java</div>
                <h1>Generic in Java (Pt. 2)</h1>
                <img src="../../img/generic_in_java_thumbnail.jfif" alt="Generic in Java (Pt. 2)"
                    class="article-thumbnail">
                <p class="article-intro">
                    In the <a href="generic_in_java.html">previous article</a>, we researched Generic in Java with
                    classes. Today we'll find out how generic works with Interface.
                </p>
            </header>

            <!-- Article Content -->
            <div class="article-content">
                <h2>An example</h2>
                <p>
                    Let's say we're developing a Library management. We have 2 interfaces, 1 to manage books, and 1 to
                    manage authors, as below:
                </p>

                <pre><code>public interface BookMgmt {
    List&lt;Book&gt; findAll();

    Book findById(String id);

    boolean addNew(Book newBook);

    boolean update(String id, Book newBook);

    boolean deleteById(String id);

    List&lt;Book&gt; findByAuthor(Author author);
}
public interface AuthorMgmt {
    List&lt;Author&gt; findAll();

    Author findById(int id);

    boolean addNew(Author newAuthor);

    boolean update(int id, Author newAuthor);

    boolean deleteById(int id);
}</code></pre>

                <p>
                    We can see that, there are many common methods in the above interfaces. The only differences are the
                    return type and the param type. So is there any way for us to remove the duplicates, but keep the
                    same features?
                </p>

                <p>Yes. It's Generic.</p>

                <h2>Generic interface</h2>
                <p>First, we create a common interface, just like the one below:</p>

                <pre><code>public interface CommonMgmt &lt;ID, E&gt; {
    List&lt;E&gt; findAll();

    E findById(ID id);

    boolean addNew(E newEntity);

    boolean update(ID id, E newEntity);

    boolean deleteById(ID id);
}</code></pre>

                <p>
                    There are 2 differences between AuthorMgmt and BookMgmt, they are ID type and return type (Entity
                    type), so we declare 2 generic types (ID stands for id and E stands for entity). The generic types
                    are declared beside the interface name for all the methods inside to use them. All of the common
                    methods are now declared.
                </p>

                <p>
                    Next, we use the BookMgmt and AuthorMgmt interfaces to extend the CommonMgmt interface and replace
                    the Generic types with the data types they would use.
                </p>

                <pre><code>public interface BookMgmt extends CommonMgmt&lt;String, Book&gt;{
    List&lt;Book&gt; findByAuthor(Author author);
}
public interface AuthorMgmt extends CommonMgmt&lt;Integer, Author&gt; {
    
}</code></pre>

                <p>
                    Because generics accept only object data types, not primitive types, we must change any primitive
                    types to the object types, such as int -> Integer, long -> Long, and so on.
                </p>

                <p>
                    Now, when we create any implementation class of the above interfaces, that class must override all
                    the common methods that we declared in the common interface.
                </p>

                <img src="../../img/generic_in_java_2.png" alt="Implementation class">
                <p class="image-caption">Implementation class</p>

                <p>
                    Besides reducing method declarations, generic can also help you to manage your code better.
                </p>

                <h2>Update generic methods</h2>
                <p>
                    Let's say you want to add a similar method to many interfaces. With the generic interface, you will
                    have to declare that method in ONLY 1 interface, and any implementation classes would have to
                    declare it.
                </p>

                <p>Now we add a new findByName method to the common interface.</p>

                <pre><code>public interface CommonMgmt &lt;ID, E&gt; {
    List&lt;E&gt; findAll();

    List&lt;E&gt; findByName(String name);

    E findById(ID id);

    boolean addNew(E newEntity);

    boolean update(ID id, E newEntity);

    boolean deleteById(ID id);
}</code></pre>

                <p>
                    Without any change in the BookMgmt interface, we can see that the BookMgmtImpl class must now
                    override the new method.
                </p>

                <img src="../../img/generic_in_java_2.png" alt="Book Management implementation class">
                <p class="image-caption">Book Management implementation class</p>
            </div>
        </article>
    </div>

    <div id="footer-placeholder"></div>

    <script src="../../js/post_layout.js"></script>
</body>

</html>
